----------
23.08.2025
----------

Let's begin development of Gleam House!

{
First thing to do is:
    1. Create an infinite grid with a checkered pattern, that will be world's "floor"
(refer to dev_plan.txt)

Let's create a class
    class Floor
in new files
    Floor.h
    Floor.cpp

    {
    Now I noticed that all our source code is in
        namespace Demo
    because I copied the setup from one of Pekan's demos.
    Let's just replace
        namespace Demo
    with
        namespace GleamHouse
    everywhere.
    }

By the way, we don't need the GUI window at all. Let's remove it. Done.

Found a bug in Pekan causing the second RectangleShape rendered in a Floor
to take the color of the first RectangleShape rendered,
if the floor is too big (81x81 or more).
Fixed it in Pekan.
Updated the Pekan dependency here.
Now it works.

----------
24.08.2025
----------

Floor is ready.
We have a grid with a checkered pattern.
It's not infinite, but we can make it as big as we want to fit the whole level.

Done.
}

{
Next thing to do is
    2. Create player's character
        2.1. Render a small sprite
        ...

First, create an image to be used for player's sprite
    src/resources/GleamHouse_player.png

Then, let's create a new class
    class Player
in new files
    Player.h
    Player.cpp
and make it render a sprite using the image as a texture.

    {
    Added this CMake option
        GLEAMHOUSE_WITH_DEBUG_GRAPHICS
    to be able to easily enable and disable debug graphics.
    For now the only debug graphics that we have is the tiny red square marking coordinate system's center.
    I don't want to see it by default so this new option will be disabled by default.
    }

Looks good.
Done.
}

{
Next thing to do is
    2. Create player's character
        ...
        2.2. Allow player to move it with WASD
        ...

(Created a file todo.txt with TO-DO items)

Created an
    update()
function in class Player.
Inside of it we'll check if W/A/S/D key is pressed and move the sprite up/left/down/right.
    if (PekanEngine::isKeyPressed(KeyCode::KEY_W))
    {
        m_sprite.move({ 0.0f, SPEED });
    }
with some constant speed
    static const float SPEED = 0.05f;
In the future it'd be good to make this speed be frame-independent using dt - created a TO-DO item for this.

That's it.
Player can be moved with WASD now. It works.
Done.
}

{
Next thing to do is
    2. Create player's character
        ...
        2.3. Make camera follow player's character automatically with a smooth motion.
            Disable camera controller, so that player can't move camera freely.
        ...

Let's create a new function in GleamHouse_Scene
    void updateCamera()
where we'll update camera's position each frame such that it follows the player.
The way we'll do this is to always move the camera some constant fraction of the distance to the player.
More specifically, let that factor be
    static constexpr float CAMERA_LERP_FACTOR = 0.05f;
and let's get player's position and camera's position
    const glm::vec2 playerPos = m_player.getPosition();
    const glm::vec2 cameraPos = m_camera->getPosition();
Then, the new camera position will be
    const glm::vec2 newCameraPos = cameraPos + (playerPos - cameraPos) * CAMERA_LERP_FACTOR;
Basically adding this fraction CAMERA_LERP_FACTOR of the vector
    playerPos - cameraPos
to the original camera position
    cameraPos

Don't forget to disable camera controller so that player can't move camera with the mouse.

That's it.
Now the camera follows the player and moves smoothly.
Done.
}

{
Next thing to do is
    2. Create player's character
        ...
        2.4. Rotate sprite so that it always faces the mouse

This one is easy, we just need the
    std::atan2(...)
function, which returns the angle that a 2D vector makes with the positive X-axis.
Inside of Player's
    update()
function we need to, first, get mouse position, in world space.
Be careful, THIS is the Pekan function that returns mouse position in world space:
    Renderer2DSystem::getMousePosition()
This one is NOT
    PekanEngine::getMousePosition()
It returns mouse position in window space.
Then, after we have the mouse position
    const glm::vec2 mousePosition = Renderer2DSystem::getMousePosition();
we can calculate the vector from player to mouse
    const glm::vec2 playerToMouseVec = mousePosition - getPosition();
and use the atan2 function to calculate the angle of this vector
    const float angle = std::atan2f(playerToMouseVec.x, playerToMouseVec.y);
and, finally set the rotation of player's sprite to be this angle, so that it points towards the mouse
    m_sprite.setRotation(angle);

It works!
Done.
}

{
Next thing to do is
    3. Create walls
        3.1. Each wall is rendered as a sprite
        ...

First, create an image to be used for a wall's sprite
    src/resources/GleamHouse_wall.png

Let's create a new class
    class Wall
in new files
    Wall.h
    Wall.cpp

Had to add support for custom texture coordinates of Sprites in Pekan to continue with this.
Did it.
Updated Pekan here.

----------
25.08.2025
----------

class Wall is ready.
Created 5 walls arranged to form a room with a small exit on the right side.
Looks good.

Done.
}

{
We actually already did the next step
    3. Create walls
        ...
        3.2. A wall never moves, in world space
        ...
by just NOT having move(), setPosition(), setSize() or similar functions in class Wall.
A wall's size and position are determined only in the create() function.
Once a wall is created its size and position cannot be changed.
}

{
Next thing to do is
    3. Create walls
        ...
        3.3. Player can't pass through walls

To do this we'll need the concept of a bounding box.
Let's create a new struct
    struct BoundingBox
in new files
    BoundingBox.h
    BoundingBox.cpp
It will represent an axis-alligned rectangle in world space
that can be used to detect collisions with other rectangles.
The main functionality of BoundingBox will be
    bool collides(BoundingBox other) const;
detecting if a BoundingBox collides with another BoundingBox.

Then, we'll use this BoundingBox struct to make walls have bounding boxes.
Add this member variable in class Wall
    BoundingBox m_boundingBox;
together with a getter
    BoundingBox getBoundingBox() const { return m_boundingBox; }
and we'll calculate the bounding box in Wall'c create() function,
only once, since a Wall is never moded or changed
    m_boundingBox.min = bottomLeftPosition - glm::vec2(BORDER_THICKNESS, BORDER_THICKNESS);
    m_boundingBox.max = topRightPosition + glm::vec2(BORDER_THICKNESS, BORDER_THICKNESS);

----------
26.08.2025
----------

For class Player we can also use a BoundingBox, but it will actually be better to have a new struct
    BoundingCircle
because the player is a circle-ish character, it's better to bound it in a circle instead of a rectangle.
So, this struct BoundingCircle will be very similar to BoundingBox,
but instead of a rectangle it will be a circle.
It will have the same collides() function
    bool collides(BoundingCircle other) const;
detecting if a BoundingCircle collides with another BoundingCircle.
However, we'll also need to detect circle-rectangle collisions, so let's add an overload of BoundingCircle's collides() function
that takes in a BoundingBox instead of a BoundingCircle
    bool collides(const BoundingBox& box) const;
(This time it's a const reference because we need to do a forward declaration of struct BoundingBox in BoundingCircle.h)
Just for consistency let's also have the opposite function in struct BoundingBox
    bool collides(const BoundingCircle& circle) const;
One of these 2 functions will just call the other so that they use the same implementation.

Okay, now that our walls have bounding boxes and we know how to detect collisions,
let's actually limit player's movement based on their collisions with walls.
We'll need to pass the list of walls as a parameter to Player's update() function
    void update(const Wall* walls, int wallsCount);
because moving the player depends on where the walls are.
Then, we'll create this helper function
    bool canMoveBy(glm::vec2 delta, const Wall* walls, int wallsCount);
in class Player, that will check if player can be moved by some delta vector
so that it doesn't collide with any walls.
To check this we can just create player's bounding circle
    const glm::vec2 newPosition = getPosition() + delta;
    BoundingCircle boundingCircle;
    boundingCircle.position = newPosition;
    boundingCircle.radius = BOUNDING_CIRCLE_RADIUS;
Decided NOT to have a bounding circle member in class Player
because the bounding circle changes every frame so we can just compute it on the fly in this canMoveBy() function.
Then, once we have player's bounding circle we can traverse all walls
    for (int i = 0; i < wallsCount; i++)
and check if a wall collides with player's bounding circle
    const BoundingBox wallBoundingBox = walls[i].getBoundingBox();
    if (boundingCircle.collides(wallBoundingBox))
    {
        return false;
    }
If it does, we can immediately return false because it's evident that player can't move there.
If we get to the end of the function without returning false, this means that player does NOT collide with any wall
so we can return true
    return true;

Then, in update() we'll use this canMoveBy() function as follows:
If a move key is pressed, we'll generate a "delta" vector
describing how player wants to move based on that pressed key
    if (PekanEngine::isKeyPressed(KeyCode::KEY_W))
    {
        const glm::vec2 delta = { 0.0f, SPEED };
        ...
    }
Then we can check if player can be moved by this delta vector using our canMoveBy() function
    if (canMoveBy(delta, walls, wallsCount))
    {
        m_sprite.move(delta);
    }
and if they can, we can move the sprite.
NOTE: It's important that we do this per key and NOT generate an accumulated delta from all 4 keys and do the canMoveBy() check on it.
      Why?
      Because, imagine a scenario where player is touching a wall to their left.
      If player presses the A key, they will NOT be able to move to the left, which is the correct behavior.
      However, if player pressed A and W keys, they will still NOT move, even though they CAN move up because nothing is blocking them from above.
      So, doing the canMoveBy() per key will ensure that we block only the left motion, but we allow the upward motion if there is nothing above.

That's it.
It works! Looks good.
Done.
}

----------
30.08.2025
----------

{
Next thing to do is
    ...
    3.4. Assemble many walls into a labyrinth with "rooms" one after the other,
         connected with complex tunnels.
         There should be a final room, where level will end.

Started doing this but I realized it's very hard to form a labyrinth by arranging walls.
It makes much more sense to arrange the floor and let everything else be walls.

Let's reverse the logic,
so that we have one big Wall as the background and many Floors where player can walk.
Okay, reversed it.
An interesting problem that occured is how to check if player is fully within the floor.
What makes it difficult is that the "floor" is really a union of many floor pieces which are rectangles.
So we can't really look for a floor piece that fully contains the player, because this breaks
when the player passes from one floor peice to another.
We need a more sophisticated approach.
We're talking about the implementation of Player's
    canMoveBy()
function.
So, here's what I did:
First, generate player's bounding box at the new position
    BoundingBox boundingBox;
    boundingBox.min = newPosition - SIZE_VEC / 2.0f;
    boundingBox.max = newPosition + SIZE_VEC / 2.0f;
We'll still use a bounding circle for the actual movement-limiting collisions,
but we'll first use this bounding box for a bit of optimization.
We want to collect all floor pieces that collide with the bounding box,
because these are the only ones that we are interested in.
All other floor pieces we can disregard because if player's bounding box doesn't collide with them
then player's bounding circle definitely doesn't.
So, in a small array of indices we will collect floor pieces that collide with player's bounding box
    int collisionIndices[MAX_FLOOR_COLLISIONS];
    int collisionsCount = 0;
We use a static array here, not a vector, because we know that the collided floor pieces will be 1, 2 or at most 3.
Just in case we reserve spacea for 6 but this amount will never be reached in practice
    static constexpr int MAX_FLOOR_COLLISIONS = 6;
So yeah, now finding those collision indices - the indices of floor peices that collide with the bounding box, happens like that:
    for (int i = 0; i < floorsCount; i++)
    {
        const BoundingBox floorBoundingBox = floors[i].getBoundingBox();
        if (boundingBox.collides(floorBoundingBox))
        {
            ...
            collisionIndices[collisionsCount++] = i;
        }
    }
Easy enough.
Then, we continue with the bounding circle.
We first generate the bounding circle
    BoundingCircle boundingCircle;
    boundingCircle.position = newPosition;
    boundingCircle.radius = BOUNDING_CIRCLE_RADIUS;
and then we need to check if this bounding circle is fully contained within the floor,
but now we can do this in a much more optimized way.
We can just check the few collided floor pieces that we already collected.
So, we need to check if the bounding circle is fully contained in the union of the collided floor pieces.
How do we do that?
We can approximate the answer by subdividing the circle with a grid of, say 8x8, points evenly spread across the circle.
If each of those points is inside one of the floor pieces then we can conclude that the whole circle is (most probably)  fully inside the union.
I'll spare the details here, see the code.
That's it.

Seems to work fine.

}