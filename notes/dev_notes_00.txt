----------
23.08.2025
----------

Let's begin development of Gleam House!

{
First thing to do is:
    1. Create an infinite grid with a checkered pattern, that will be world's "floor"
(refer to dev_plan.txt)

Let's create a class
    class Floor
in new files
    Floor.h
    Floor.cpp

    {
    Now I noticed that all our source code is in
        namespace Demo
    because I copied the setup from one of Pekan's demos.
    Let's just replace
        namespace Demo
    with
        namespace GleamHouse
    everywhere.
    }

By the way, we don't need the GUI window at all. Let's remove it. Done.

Found a bug in Pekan causing the second RectangleShape rendered in a Floor
to take the color of the first RectangleShape rendered,
if the floor is too big (81x81 or more).
Fixed it in Pekan.
Updated the Pekan dependency here.
Now it works.

----------
24.08.2025
----------

Floor is ready.
We have a grid with a checkered pattern.
It's not infinite, but we can make it as big as we want to fit the whole level.

Done.
}

{
Next thing to do is
    2. Create player's character
        2.1. Render a small sprite
        ...

First, create a texture to be used for player's sprite
    src/resources/GleamHouse_player.png

Then, let's create a new class
    class Player
in new files
    Player.h
    Player.cpp
and make it render a sprite using the image as a texture.

    {
    Added this CMake option
        GLEAMHOUSE_WITH_DEBUG_GRAPHICS
    to be able to easily enable and disable debug graphics.
    For now the only debug graphics that we have is the tiny red square marking coordinate system's center.
    I don't want to see it by default so this new option will be disabled by default.
    }

Looks good.
Done.
}

{
Next thing to do is
    2. Create player's character
        ...
        2.2. Allow player to move it with WASD
        ...

(Created a file todo.txt with TO-DO items)

Created an
    update()
function in class Player.
Inside of it we'll check if W/A/S/D key is pressed and move the sprite up/left/down/right.
    if (PekanEngine::isKeyPressed(KeyCode::KEY_W))
    {
        m_sprite.move({ 0.0f, SPEED });
    }
with some constant speed
    static const float SPEED = 0.05f;
In the future it'd be good to make this speed be frame-independent using dt - created a TO-DO item for this.

That's it.
Player can be moved with WASD now. It works.
Done.
}

{
Next thing to do is
    2. Create player's character
        ...
        2.3. Make camera follow player's character automatically with a smooth motion.
            Disable camera controller, so that player can't move camera freely.
        ...

Let's create a new function in GleamHouse_Scene
    void updateCamera()
where we'll update camera's position each frame such that it follows the player.
The way we'll do this is to always move the camera some constant fraction of the distance to the player.
More specifically, let that factor be
    static constexpr float CAMERA_LERP_FACTOR = 0.05f;
and let's get player's position and camera's position
    const glm::vec2 playerPos = m_player.getPosition();
    const glm::vec2 cameraPos = m_camera->getPosition();
Then, the new camera position will be
    const glm::vec2 newCameraPos = cameraPos + (playerPos - cameraPos) * CAMERA_LERP_FACTOR;
Basically adding this fraction CAMERA_LERP_FACTOR of the vector
    playerPos - cameraPos
to the original camera position
    cameraPos

Don't forget to disable camera controller so that player can't move camera with the mouse.

That's it.
Now the camera follows the player and moves smoothly.
Done.
}

{
Next thing to do is
    2. Create player's character
        ...
        2.4. Rotate sprite so that it always faces the mouse

This one is easy, we just need the
    std::atan2(...)
function, which returns the angle that a 2D vector makes with the positive X-axis.
Inside of Player's
    update()
function we need to, first, get mouse position, in world space.
Be careful, THIS is the Pekan function that returns mouse position in world space:
    Renderer2DSystem::getMousePosition()
This one is NOT
    PekanEngine::getMousePosition()
It returns mouse position in window space.
Then, after we have the mouse position
    const glm::vec2 mousePosition = Renderer2DSystem::getMousePosition();
we can calculate the vector from player to mouse
    const glm::vec2 playerToMouseVec = mousePosition - getPosition();
and use the atan2 function to calculate the angle of this vector
    const float angle = std::atan2f(playerToMouseVec.x, playerToMouseVec.y);
and, finally set the rotation of player's sprite to be this angle, so that it points towards the mouse
    m_sprite.setRotation(angle);

It works!
Done.
}
