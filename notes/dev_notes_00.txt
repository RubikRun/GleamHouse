----------
23.08.2025
----------

Let's begin development of Gleam House!

{
First thing to do is:
    1. Create an infinite grid with a checkered pattern, that will be world's "floor"
(refer to dev_plan.txt)

Let's create a class
    class Floor
in new files
    Floor.h
    Floor.cpp

    {
    Now I noticed that all our source code is in
        namespace Demo
    because I copied the setup from one of Pekan's demos.
    Let's just replace
        namespace Demo
    with
        namespace GleamHouse
    everywhere.
    }

By the way, we don't need the GUI window at all. Let's remove it. Done.

Found a bug in Pekan causing the second RectangleShape rendered in a Floor
to take the color of the first RectangleShape rendered,
if the floor is too big (81x81 or more).
Fixed it in Pekan.
Updated the Pekan dependency here.
Now it works.

----------
24.08.2025
----------

Floor is ready.
We have a grid with a checkered pattern.
It's not infinite, but we can make it as big as we want to fit the whole level.

Done.
}

{
Next thing to do is
    2. Create player's character
        2.1. Render a small sprite
        ...

First, create an image to be used for player's sprite
    src/resources/GleamHouse_player.png

Then, let's create a new class
    class Player
in new files
    Player.h
    Player.cpp
and make it render a sprite using the image as a texture.

    {
    Added this CMake option
        GLEAMHOUSE_WITH_DEBUG_GRAPHICS
    to be able to easily enable and disable debug graphics.
    For now the only debug graphics that we have is the tiny red square marking coordinate system's center.
    I don't want to see it by default so this new option will be disabled by default.
    }

Looks good.
Done.
}

{
Next thing to do is
    2. Create player's character
        ...
        2.2. Allow player to move it with WASD
        ...

(Created a file todo.txt with TO-DO items)

Created an
    update()
function in class Player.
Inside of it we'll check if W/A/S/D key is pressed and move the sprite up/left/down/right.
    if (PekanEngine::isKeyPressed(KeyCode::KEY_W))
    {
        m_sprite.move({ 0.0f, SPEED });
    }
with some constant speed
    static const float SPEED = 0.05f;
In the future it'd be good to make this speed be frame-independent using dt - created a TO-DO item for this.

That's it.
Player can be moved with WASD now. It works.
Done.
}

{
Next thing to do is
    2. Create player's character
        ...
        2.3. Make camera follow player's character automatically with a smooth motion.
            Disable camera controller, so that player can't move camera freely.
        ...

Let's create a new function in GleamHouse_Scene
    void updateCamera()
where we'll update camera's position each frame such that it follows the player.
The way we'll do this is to always move the camera some constant fraction of the distance to the player.
More specifically, let that factor be
    static constexpr float CAMERA_LERP_FACTOR = 0.05f;
and let's get player's position and camera's position
    const glm::vec2 playerPos = m_player.getPosition();
    const glm::vec2 cameraPos = m_camera->getPosition();
Then, the new camera position will be
    const glm::vec2 newCameraPos = cameraPos + (playerPos - cameraPos) * CAMERA_LERP_FACTOR;
Basically adding this fraction CAMERA_LERP_FACTOR of the vector
    playerPos - cameraPos
to the original camera position
    cameraPos

Don't forget to disable camera controller so that player can't move camera with the mouse.

That's it.
Now the camera follows the player and moves smoothly.
Done.
}

{
Next thing to do is
    2. Create player's character
        ...
        2.4. Rotate sprite so that it always faces the mouse

This one is easy, we just need the
    std::atan2(...)
function, which returns the angle that a 2D vector makes with the positive X-axis.
Inside of Player's
    update()
function we need to, first, get mouse position, in world space.
Be careful, THIS is the Pekan function that returns mouse position in world space:
    Renderer2DSystem::getMousePosition()
This one is NOT
    PekanEngine::getMousePosition()
It returns mouse position in window space.
Then, after we have the mouse position
    const glm::vec2 mousePosition = Renderer2DSystem::getMousePosition();
we can calculate the vector from player to mouse
    const glm::vec2 playerToMouseVec = mousePosition - getPosition();
and use the atan2 function to calculate the angle of this vector
    const float angle = std::atan2f(playerToMouseVec.x, playerToMouseVec.y);
and, finally set the rotation of player's sprite to be this angle, so that it points towards the mouse
    m_sprite.setRotation(angle);

It works!
Done.
}

{
Next thing to do is
    3. Create walls
        3.1. Each wall is rendered as a sprite
        ...

First, create an image to be used for a wall's sprite
    src/resources/GleamHouse_wall.png

Let's create a new class
    class Wall
in new files
    Wall.h
    Wall.cpp

Had to add support for custom texture coordinates of Sprites in Pekan to continue with this.
Did it.
Updated Pekan here.

----------
25.08.2025
----------

class Wall is ready.
Created 5 walls arranged to form a room with a small exit on the right side.
Looks good.

Done.
}

{
We actually already did the next step
    3. Create walls
        ...
        3.2. A wall never moves, in world space
        ...
by just NOT having move(), setPosition(), setSize() or similar functions in class Wall.
A wall's size and position are determined only in the create() function.
Once a wall is created its size and position cannot be changed.
}

{
Next thing to do is
    3. Create walls
        ...
        3.3. Player can't pass through walls

To do this we'll need the concept of a bounding box.
Let's create a new struct
    struct BoundingBox
in new files
    BoundingBox.h
    BoundingBox.cpp
It will represent an axis-alligned rectangle in world space
that can be used to detect collisions with other rectangles.
The main functionality of BoundingBox will be
    bool collides(BoundingBox other) const;
detecting if a BoundingBox collides with another BoundingBox.

Then, we'll use this BoundingBox struct to make walls have bounding boxes.
Add this member variable in class Wall
    BoundingBox m_boundingBox;
together with a getter
    BoundingBox getBoundingBox() const { return m_boundingBox; }
and we'll calculate the bounding box in Wall'c create() function,
only once, since a Wall is never moded or changed
    m_boundingBox.min = bottomLeftPosition - glm::vec2(BORDER_THICKNESS, BORDER_THICKNESS);
    m_boundingBox.max = topRightPosition + glm::vec2(BORDER_THICKNESS, BORDER_THICKNESS);

----------
26.08.2025
----------

For class Player we can also use a BoundingBox, but it will actually be better to have a new struct
    BoundingCircle
because the player is a circle-ish character, it's better to bound it in a circle instead of a rectangle.
So, this struct BoundingCircle will be very similar to BoundingBox,
but instead of a rectangle it will be a circle.
It will have the same collides() function
    bool collides(BoundingCircle other) const;
detecting if a BoundingCircle collides with another BoundingCircle.
However, we'll also need to detect circle-rectangle collisions, so let's add an overload of BoundingCircle's collides() function
that takes in a BoundingBox instead of a BoundingCircle
    bool collides(const BoundingBox& box) const;
(This time it's a const reference because we need to do a forward declaration of struct BoundingBox in BoundingCircle.h)
Just for consistency let's also have the opposite function in struct BoundingBox
    bool collides(const BoundingCircle& circle) const;
One of these 2 functions will just call the other so that they use the same implementation.

Okay, now that our walls have bounding boxes and we know how to detect collisions,
let's actually limit player's movement based on their collisions with walls.
We'll need to pass the list of walls as a parameter to Player's update() function
    void update(const Wall* walls, int wallsCount);
because moving the player depends on where the walls are.
Then, we'll create this helper function
    bool canMoveBy(glm::vec2 delta, const Wall* walls, int wallsCount);
in class Player, that will check if player can be moved by some delta vector
so that it doesn't collide with any walls.
To check this we can just create player's bounding circle
    const glm::vec2 newPosition = getPosition() + delta;
    BoundingCircle boundingCircle;
    boundingCircle.position = newPosition;
    boundingCircle.radius = BOUNDING_CIRCLE_RADIUS;
Decided NOT to have a bounding circle member in class Player
because the bounding circle changes every frame so we can just compute it on the fly in this canMoveBy() function.
Then, once we have player's bounding circle we can traverse all walls
    for (int i = 0; i < wallsCount; i++)
and check if a wall collides with player's bounding circle
    const BoundingBox wallBoundingBox = walls[i].getBoundingBox();
    if (boundingCircle.collides(wallBoundingBox))
    {
        return false;
    }
If it does, we can immediately return false because it's evident that player can't move there.
If we get to the end of the function without returning false, this means that player does NOT collide with any wall
so we can return true
    return true;

Then, in update() we'll use this canMoveBy() function as follows:
If a move key is pressed, we'll generate a "delta" vector
describing how player wants to move based on that pressed key
    if (PekanEngine::isKeyPressed(KeyCode::KEY_W))
    {
        const glm::vec2 delta = { 0.0f, SPEED };
        ...
    }
Then we can check if player can be moved by this delta vector using our canMoveBy() function
    if (canMoveBy(delta, walls, wallsCount))
    {
        m_sprite.move(delta);
    }
and if they can, we can move the sprite.
NOTE: It's important that we do this per key and NOT generate an accumulated delta from all 4 keys and do the canMoveBy() check on it.
      Why?
      Because, imagine a scenario where player is touching a wall to their left.
      If player presses the A key, they will NOT be able to move to the left, which is the correct behavior.
      However, if player pressed A and W keys, they will still NOT move, even though they CAN move up because nothing is blocking them from above.
      So, doing the canMoveBy() per key will ensure that we block only the left motion, but we allow the upward motion if there is nothing above.

That's it.
It works! Looks good.
Done.
}

----------
30.08.2025
----------

{
Next thing to do is
    ...
    3.4. Assemble many walls into a labyrinth with "rooms" one after the other,
         connected with complex tunnels.
         There should be a final room, where level will end.

Started doing this but I realized it's very hard to form a labyrinth by arranging walls.
It makes much more sense to arrange the floor and let everything else be walls.

Let's reverse the logic,
so that we have one big Wall as the background and many Floors where player can walk.
Okay, reversed it.
An interesting problem that occured is how to check if player is fully within the floor.
What makes it difficult is that the "floor" is really a union of many floor pieces which are rectangles.
So we can't really look for a floor piece that fully contains the player, because this breaks
when the player passes from one floor peice to another.
We need a more sophisticated approach.
We're talking about the implementation of Player's
    canMoveBy()
function.
So, here's what I did:
First, generate player's bounding box at the new position
    BoundingBox boundingBox;
    boundingBox.min = newPosition - SIZE_VEC / 2.0f;
    boundingBox.max = newPosition + SIZE_VEC / 2.0f;
We'll still use a bounding circle for the actual movement-limiting collisions,
but we'll first use this bounding box for a bit of optimization.
We want to collect all floor pieces that collide with the bounding box,
because these are the only ones that we are interested in.
All other floor pieces we can disregard because if player's bounding box doesn't collide with them
then player's bounding circle definitely doesn't.
So, in a small array of indices we will collect floor pieces that collide with player's bounding box
    int collisionIndices[MAX_FLOOR_COLLISIONS];
    int collisionsCount = 0;
We use a static array here, not a vector, because we know that the collided floor pieces will be 1, 2 or at most 3.
Just in case we reserve spacea for 6 but this amount will never be reached in practice
    static constexpr int MAX_FLOOR_COLLISIONS = 6;
So yeah, now finding those collision indices - the indices of floor peices that collide with the bounding box, happens like that:
    for (int i = 0; i < floorsCount; i++)
    {
        const BoundingBox floorBoundingBox = floors[i].getBoundingBox();
        if (boundingBox.collides(floorBoundingBox))
        {
            ...
            collisionIndices[collisionsCount++] = i;
        }
    }
Easy enough.
Then, we continue with the bounding circle.
We first generate the bounding circle
    BoundingCircle boundingCircle;
    boundingCircle.position = newPosition;
    boundingCircle.radius = BOUNDING_CIRCLE_RADIUS;
and then we need to check if this bounding circle is fully contained within the floor,
but now we can do this in a much more optimized way.
We can just check the few collided floor pieces that we already collected.
So, we need to check if the bounding circle is fully contained in the union of the collided floor pieces.
How do we do that?
We can approximate the answer by subdividing the circle with a grid of, say 8x8, points evenly spread across the circle.
If each of those points is inside one of the floor pieces then we can conclude that the whole circle is (most probably)  fully inside the union.
I'll spare the details here, see the code.
That's it.

Seems to work fine.

Now, much more easily, we can arrange floor pieces to form the labyrinth.
Let's do that.
Okay, done.
Created the map from 21 floor pieces.

Noticed a small detail that annoys me.
Some floor pieces (those with an odd size) end with a black square
and next to them another floor piece starts with a black square,
resulting in 2 black squares next to each other (or vice versa).
The only way to fix this is to allow users of class Floor to specify the color of row 0 col 0.
(Currently we are always making it black)
So, added a bool parameter to Floor's create() function
    bool create(glm::ivec2 bottomLeftPosition, glm::ivec2 topRightPosition, bool isBottomLeftBlack = true);
and we'll manually pass true/false depending on which floor piece we are creating.
That's it.
Now there are no 2 tiles of the same color next to each other.

Map design for level 1 is done.
Done.
}

----------
04.09.2025
----------

{
For the next step
    4. Create a post-processing shader with a uniform array of light positions,
    together with a uniform array of light intensities, and a uniform array of light colors.
    This shader will apply lighting on top of what is already rendered.
I had to take a detour and implement post-processing shaders in Pekan.
Did it.
Updated Pekan here.

Now let's actually implement the lights shader here in Gleam House.
    shaders/PostProcessingShader.glsl
Done.
It supports multiple lights, where each light consists of
- a position (in window space)
- intensity (between 0 and 1)
- radius (in world space)
- sharpness (between 0 and 1)

Currently made it so that there is a single light and it's right on top of player.

Looks good.
Done.
}

----------
07.09.2025
----------

{
Next thing to do is:
    5. Create a star
        5.1. A big star will mark level's ending. It will be in the center of the final room
        5.2. A star will be passed to the post-processing shader as a light with big intensity,
             so that it shines really brightly with a big radius, and a white-ish color.
        ...

Okay, had to extend
    PostProcessingShader.glsl
with a list of "isStar" flags for lights,
because we want to treat star light a bit differenly from normal light.
We want to sum the contribution of all normal lights and cap that at 1.0
but we don't want to cap the star lights, we want to allow more than 100% light,
so that in the center of a star everything should be just white (or whatever the star's color is).
So, in
    PostProcessingShader.glsl
we will first sum normal lights by just skipping stars in the for loop
    if (uLightIsStarFlags[i] > 0.0)
    {
        continue;
    }
then we'll cap the sum
    lightSum = min(lightSum, 1.0 - baseLight);
and then we'll sum star lights by just skipping normal lights in the for loop
    if (uLightIsStarFlags[i] < 1.0)
    {
        continue;
    }
and NOT capping anything after that.
That's it.

Then, I created a star at the end of the level - in the bottom-left corner of the final room.
Configured its light parameters so that it shines a little bit into the initial room,
so that at the beginning of the level player can see where the star is, or at least at what direction.
The star is NOT, however, strong enough to light the rest of player' path.
Player must continue in darkness after the first room.
Looks good.

Done.
}

{
Next thing to do is
    5. Create a star
        ...
        5.3. When player goes inside a star, the star's intensity will grow
            such that when player is sufficiently close to the center everything will be white.
            When everything becomes white, the level is complete
            and a text will appear, fading in, staying for 8s and fading out, saying
                Completed Level 1!
            (NOTE: Pekan doesn't support text rendering but we can have an image with the text)

Okay, first made the star increase its intensity and change its color from blue-ish to white gradually
as player gets closer to star's center.

Then, decided to experiment a little and added a whole new "Finished Level" scene
that shows up when you finish the level and says
    "Finished Level 1"
Since we don't support text rendering yet in Pekan I added an image with the text written on it.
This image is displayed in the "Finished Level" scene on a sprite.
There's a fun detail that I added.
At the end of the level the control is taken away from player,
and the character starts rotating by itself.
At this point it's so far into the star that everything is white,
except their headphones which are blue.
Those headphones look like the letter "I" so I decided to write the "Finished Level"
text in a similar "font" and cutting out the first "I" so that player's character can be there
and replace the letter.
It looks nice.
There were a couple of things that I had to do to make it work.
Nothing worth mentioning tho, so leaving it at that.

Done.
}

----------
14.09.2025
----------

{
Continue with the next thing to do:
    6. Create torches
        6.1. A torch will be rendered as a thin vertical rectangle,
            together with a bunch of lines above it, forming a rhombus shape.
            The lines will be random shades of red/orange,
            changing every 1/N seconds, looking like fire.

Okay, created a class
    class Torch
in 2 new files
    Torch.h
    Torch.cpp
For now, it just renders a torch as a base rectangle with a bunch of lines on top forming a rhombus shape.
Lines change colors every few frames.
A light is passed to the post-processing shader on the position of torch's fire.
Currently this is done manually in the main scene, we'll look into abstracting it away,
so that multiple torches can be handled more easily and we can animate their lights.
Looks good so far.

Now let's create a new struct
    struct LightProperties
in a new file
    LightProperties.h
It will be just a struct holding together the properties of a light - position, color, intensity, etc.
Then let's create this static function
    static void updatePostProcessingShader(const std::vector<LightProperties> lights)
in
    GleamHouse_Scene.cpp
that updates the uniforms in the post-processing shader based on a given list of light properties.
We will use that function, call it, in updateLights().
Okay, done.
Works the same, but code looks better now.

}